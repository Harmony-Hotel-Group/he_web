---
// src/components/atoms/Imagen.astro
/**
 * Componente optimizado para imágenes
 * Soporta: local (/src/resources/img/), public (/public/), y URLs remotas
 * Con validación, cache y fallback automático
 */

import { Image } from "astro:assets";
import { promises as fs } from "node:fs";
import path from "node:path";
import type { ImageMetadata } from "astro";
import { logger } from "@/services/logger.ts";

const log = logger("Imagen");

interface Props {
	id?: string;
	src: string | ImageMetadata | null | undefined;
	alt: string;
	width: number;
	height: number;
	class?: string;
	loading?: "lazy" | "eager";
	decoding?: "async" | "sync" | "auto";
	quality?: number;
	format?: "webp" | "avif" | "png" | "jpg";
	fetchpriority?: "auto" | "high" | "low";
}

const {
	id,
	src,
	alt,
	width,
	height,
	class: className,
	loading = "lazy",
	decoding = "async",
	quality = 80,
	format,
	fetchpriority = "auto",
} = Astro.props;
log.info({
	id,
	src,
	alt,
	width,
	height,
	class: className,
	loading,
	decoding,
	quality,
	format,
	fetchpriority,
});
// ==================== CACHE ====================

const validationCache = new Map<string, boolean>();

// ==================== HELPERS ====================

async function existeEnPublic(rutaPublica: string): Promise<boolean> {
	const cacheKey = `public:${rutaPublica}`;
	if (validationCache.has(cacheKey)) {
		return validationCache.get(cacheKey) ?? false;
	}

	try {
		const rutaCompleta = path.join(process.cwd(), "public", rutaPublica);
		await fs.access(rutaCompleta);
		validationCache.set(cacheKey, true);
		return true;
	} catch {
		validationCache.set(cacheKey, false);
		return false;
	}
}

async function urlExist(url: string): Promise<boolean> {
	const cacheKey = `remote:${url}`;
	if (validationCache.has(cacheKey)) {
		return validationCache.get(cacheKey) ?? false;
	}

	try {
		const controller = new AbortController();
		const timeoutId = setTimeout(() => controller.abort(), 3000);

		const res = await fetch(url, {
			method: "HEAD",
			signal: controller.signal,
		});

		clearTimeout(timeoutId);

		if (!res.ok) {
			validationCache.set(cacheKey, false);
			return false;
		}

		const contentType = res.headers.get("content-type") || "";
		const isImage = contentType.startsWith("image/");

		validationCache.set(cacheKey, isImage);
		return isImage;
	} catch (e) {
		log.warn(`No se pudo validar URL: ${url}`, e);
		validationCache.set(cacheKey, true);
		return true;
	}
}

function getPlaceholder(w: number, h: number, text?: string): string {
	const displayText = text || `${w}x${h}`;
	return `https://placehold.co/${w}x${h}/EAEAEA/29333B?text=${encodeURIComponent(displayText)}`;
}

// ==================== VALIDACIÓN DE SRC ====================

import { ASSETS } from "@/constants/img.ts";

function resolveImageFromAssets(path: string): ImageMetadata | undefined {
	// 1. Intentar acceso directo por clave (si el usuario pasó "USD" o "FACADE_SUN")
	if (ASSETS[path]) return ASSETS[path];

	// 2. Normalizar ruta para intentar derivar la clave
	// /src/assets/img/hotel/facade/sun.png -> hotel/facade/sun.png
	// /currents/usd.svg -> currents/usd.svg
	let cleanPath = path;
	if (cleanPath.startsWith("/src/assets/img/")) {
		cleanPath = cleanPath.replace("/src/assets/img/", "");
	} else if (cleanPath.startsWith("/img/")) {
		cleanPath = cleanPath.replace("/img/", "");
	} else if (cleanPath.startsWith("/")) {
		cleanPath = cleanPath.substring(1);
	}

	// 3. Estrategia por nombre de archivo simple (para flags/currents)
	// currents/usd.svg -> USD
	const fileName = cleanPath.split("/").pop()?.split(".")[0]?.toUpperCase();
	if (fileName && ASSETS[fileName]) return ASSETS[fileName];

	// 4. Estrategia anidada (para hotel/cities)
	// hotel/facade/sun.png -> hotel/facade/sun -> FACADE_SUN (removiendo el prefijo de carpeta raiz si es posible)

	// Detectar categoría para limpiar prefijo
	let relativePath = cleanPath;
	if (relativePath.startsWith("hotel/"))
		relativePath = relativePath.replace("hotel/", "");
	else if (relativePath.startsWith("cities/"))
		relativePath = relativePath.replace("cities/", "");

	// Convertir a formato de clave: facade/sun -> FACADE_SUN
	const nestedKey = relativePath
		.split(".")[0]
		.replace(/\//g, "_")
		.toUpperCase();
	if (ASSETS[nestedKey]) return ASSETS[nestedKey];

	return undefined;
}

let finalSrc: string = getPlaceholder(width, height);
let optimizedSrc: ImageMetadata | null = null;
let useOptimizedImage = false;

if (!src) {
	log.warn("No se proporcionó 'src', usando placeholder.");
} else if (typeof src === "object" && src !== null) {
	optimizedSrc = src;
	useOptimizedImage = true;
	log.info(`Usando imagen optimizada pasada por prop`);
} else {
	// Intentar resolver usando constantes globales
	const assetImage = resolveImageFromAssets(src);

	if (assetImage) {
		optimizedSrc = assetImage;
		useOptimizedImage = true;
		log.info(`Usando imagen constante: ${src}`);
	} else if (src.startsWith("/") || src.startsWith(".")) {
		// Fallback lógica antigua para /public o si falló la resolución de assets
		// Nota: ya no usamos glob dinámico aquí, solo verificamos public
		const existsInPublic = await existeEnPublic(src);

		if (existsInPublic) {
			finalSrc = src;
			useOptimizedImage = false;
			log.info(`Usando imagen de /public/: ${src}`);
		} else {
			log.warn(
				`Imagen local no encontrada en ASSETS ni en /public: ${src}`,
			);
			finalSrc = getPlaceholder(width, height, "No encontrada");
		}
	} else if (src.startsWith("http://") || src.startsWith("https://")) {
		const isValid = await urlExist(src);

		if (isValid) {
			finalSrc = src;
			useOptimizedImage = false;
			log.info(`Usando URL remota: ${src}`);
		} else {
			log.warn(`URL remota inválida o inaccesible: ${src}`);
			finalSrc = getPlaceholder(width, height, "URL inválida");
		}
	} else {
		log.warn(`Formato de src no reconocido: ${src}`);
		finalSrc = getPlaceholder(width, height, "Formato inválido");
	}
}
---

{
	useOptimizedImage && optimizedSrc ? (
		<Image
			id={id}
			src={optimizedSrc}
			alt={alt}
			width={width}
			height={height}
			class:list={[className]}
			loading={loading}
			decoding={decoding}
			quality={quality}
			format={format}
			fetchpriority={fetchpriority}
		/>
	) : (
		<img
			id={id}
			src={finalSrc}
			alt={alt}
			width={width}
			height={height}
			class:list={[className]}
			loading={loading}
			decoding={decoding}
		/>
	)
}

<script>
	import { logger } from "@/services/logger.ts";

	const log = logger("Imagen:Cliente");

	class ImagenErrorHandler {
		constructor() {
			this.initErrorHandling();
		}

		private initErrorHandling() {
			document.addEventListener(
				"error",
				(e) => {
					const target = e.target as HTMLElement;

					if (target.tagName === "IMG") {
						this.handleImageError(target as HTMLImageElement);
					}
				},
				true,
			);
		}

		private handleImageError(img: HTMLImageElement) {
			if (img.src.includes("placehold.co")) {
				return;
			}

			const width = img.width || 600;
			const height = img.height || 400;

			log.error("Error cargando imagen en el cliente:", img.src);

			img.src = `https://placehold.co/${width}x${height}/EAEAEA/29333B?text=Error+de+Carga`;
			img.alt = "Error cargando imagen";
			img.classList.add("image-error");
			img.onerror = null;
		}
	}

	if (
		typeof window !== "undefined" &&
		!window.hasOwnProperty("imagenErrorHandler")
	) {
		(window as any).imagenErrorHandler = new ImagenErrorHandler();
	}
</script>

<style is:global>
	img.image-error {
		border: 2px dashed #fcc;
		background: #fee;
		padding: 0.5rem;
	}
</style>
