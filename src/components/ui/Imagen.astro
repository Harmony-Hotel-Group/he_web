---
// src/components/ui/Imagen.astro
import { Image } from 'astro:assets';

interface Props {
  src: string | null | undefined;
  alt: string;
  width: number;
  height: number;
  class?: string;
}

const { src, alt, width, height, class: className } = Astro.props;

let finalSrc: any = src;
let useAstroImage = false;

// --- Server-Side Validation ---

// Prepare the placeholder URL for fallbacks
const placeholderText = encodeURIComponent(alt || `${width}x${height}`);
const placeholderSrc = `https://placehold.co/${width}x${height}/EAEAEA/29333B?text=${placeholderText}`;

if (src && (src.startsWith('/') || src.startsWith('.'))) {
  // --- Handle Local Images ---
  // For optimization, local images must be in /src/assets/images/
  const images = import.meta.glob('/src/resources/img/**/*.{jpeg,jpg,png,gif,webp,svg}');
  const imagePath = `/src/resources${src.startsWith('/imag') ? src : '/img' + src}`; // Normalize path

  if (images[imagePath]) {
    // If the image exists in our glob, we can use Astro's <Image> component.
    finalSrc = (await images[imagePath]()).default;
    useAstroImage = true;
  } else {
    // If it's a local path but not in /src/assets, we assume it's in /public
    // and will be handled by the standard <img> tag.
    finalSrc = src;
    useAstroImage = false;
  }
} else if (src && src.startsWith('http')) {
  // --- Handle Remote Images ---
  // We can't reliably check if they exist at build time.
  // So, we use the standard <img> tag with an onerror fallback.
  finalSrc = src;
  useAstroImage = false;
} else {
  // --- Handle Invalid or Missing Src ---
  // If src is null, undefined, or an invalid format, use the placeholder.
  finalSrc = placeholderSrc;
  useAstroImage = false;
}
---

{useAstroImage ? (
  // Use Astro's <Image> for optimized, known local assets from /src/assets
  <Image
    src={finalSrc}
    alt={alt}
    width={width}
    height={height}
    class:list={[className]}
    loading="lazy"
    decoding="async"
  />
) : (
  // Use standard <img> for remote URLs or images in /public
  // This gives us the robust `onerror` client-side fallback.
  <img
    src={finalSrc}
    alt={alt}
    width={width}
    height={height}
    class:list={[className]}
    loading="lazy"
    decoding="async"
    onerror={`
      const fallbackSrc = '${placeholderSrc}';
      if (this.src !== fallbackSrc) {
        this.src = fallbackSrc;
      }
      this.onerror = null;
    `}
  />
)}
