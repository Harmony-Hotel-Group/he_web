---
// src/components/atoms/DateRangePicker.astro
/**
 * DateRangePicker con sincronización automática
 * Se sincroniza con otros DatePickers del mismo syncGroup
 */

interface Props {
    id: string;
    lang?: string;
    name?: string;
    placeholder?: string;
    syncGroup?: string; // Grupo de sincronización (default: 'booking')
}

const {
    id,
    name,
    lang,
    placeholder,
    syncGroup = "booking", // Por defecto todos los date pickers de booking se sincronizan
} = Astro.props;
---

<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
/>

<div class="relative w-full">
    <label for={id}></label>
    <input
        id={id}
        name={name}
        type="text"
        data-lang={lang}
        data-for-id={id}
        data-sync-group={syncGroup}
        placeholder={placeholder}
        readonly
        class="w-full p-2 border rounded-md cursor-pointer date-range-picker-input"
    />
</div>

<style>
    .date-range-picker-input {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        background: white;
        cursor: pointer;
    }

    .date-range-picker-input:focus {
        outline: none;
        ring: 2px;
        ring-color: rgb(59 130 246);
        border-color: rgb(59 130 246);
    }

    /* Asegurar que el calendario siempre quede por encima de overlays (hero, modales) */
    .flatpickr-calendar {
        z-index: 10000 !important;
    }
</style>

<script>
    import flatpickr from "flatpickr";
    import "flatpickr/dist/l10n/es.js";
    import { DEFAULT_LANG, Translations } from "@/i18n/translation.ts";
    import { datePickerSync } from "@/utils/date-picker-sync.ts";

    import { logger } from "@/services/logger.ts";

    const log = logger("DateRangePicker");

    // --- Función de inicialización robusta ---
    function initializeDatePicker(inputElement: HTMLInputElement) {
        if (!inputElement || inputElement.dataset.flatpickrInitialized) {
            return; // Ya inicializado o no es un input válido
        }

        const lang = inputElement.dataset.lang || DEFAULT_LANG;
        const syncGroup = inputElement.dataset.syncGroup || "booking";
        const pickerId = inputElement.id;
        const t = Translations(lang);

        flatpickr(inputElement, {
            mode: "range",
            minDate: "today",
            dateFormat: "Y/m/d",
            locale: lang as "es", // Forzar el tipado si es necesario
            showMonths: 1,
            enableTime: false,

            onChange: (selectedDates, dateStr, instance) => {
                if (selectedDates.length < 2) {
                    // No hacer nada hasta que se seleccione un rango completo
                    return;
                }

                const [start, end] = selectedDates;

                if (start.toDateString() === end.toDateString()) {
                    instance.clear();
                    const message =
                        t("booking.dateRange.sameDayError") ||
                        "Debes seleccionar al menos 2 días diferentes.";
                    alert(message);
                    return;
                }

                const nights = Math.round(
                    (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24),
                );
                const nightsLabel =
                    t("components.dateRangePicker", {
                        n: nights,
                        s: nights === 1 ? "" : "s",
                    }) || `${nights} noche${nights === 1 ? "" : "s"}`;

                const formatDate = (d: Date) => d.toLocaleDateString("en-CA"); // YYYY-MM-DD
                const text = `${formatDate(start)} ➜ ${formatDate(end)} (${nightsLabel})`;

                inputElement.value = text;
                inputElement.title = text;

                datePickerSync.sync(pickerId, text, selectedDates, syncGroup);

                const changeEvent = new CustomEvent("datepicker:change", {
                    detail: {
                        pickerId,
                        value: text,
                        dates: selectedDates,
                        nights,
                        syncGroup,
                    },
                    bubbles: true,
                });
                inputElement.dispatchEvent(changeEvent);
            },

            onReady: (selectedDates, dateStr, instance) => {
                datePickerSync.register(pickerId, instance, syncGroup);
                inputElement.dataset.flatpickrInitialized = "true"; // Marcar como inicializado
                log.info(`Initialized: ${pickerId}`);
            },

            onDestroy: () => {
                datePickerSync.unregister(pickerId, syncGroup);
                delete inputElement.dataset.flatpickrInitialized;
            },
        });
    }

    // --- Exponer la función globalmente para poder llamarla desde otros scripts ---
    window.initializeAllDatePickers = () => {
        const inputs = document.querySelectorAll(".date-range-picker-input");
        inputs.forEach((input) => {
            if (input instanceof HTMLInputElement) {
                initializeDatePicker(input);
            }
        });
        log.info(`Attempted to initialize ${inputs.length} pickers.`);
    };

    // --- Inicialización automática al cargar la página ---
    // Usamos un pequeño retraso para asegurar que todo el DOM esté listo
    document.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => {
            window.initializeAllDatePickers();
        }, 100);
    });

    // --- Observador para elementos dinámicos (como en modales) ---
    // Este es un fallback útil si los componentes se cargan de forma asíncrona
    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type === "childList") {
                const target = mutation.target;
                if (target instanceof Element) {
                    const newPickers = target.querySelectorAll(
                        ".date-range-picker-input:not([data-flatpickr-initialized])",
                    );
                    if (newPickers.length > 0) {
                        log.info(
                            `Detected ${newPickers.length} new pickers. Initializing...`,
                        );
                        window.initializeAllDatePickers();
                        break; // Solo necesitamos ejecutarlo una vez
                    }
                }
            }
        }
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true,
    });
</script>
